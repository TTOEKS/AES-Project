#include "aes.h"


/*

	S-BOX
	// 0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76 // 0
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0 // 1
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15 // 2
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75 // 3
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84 // 4
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf // 5
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8 // 6
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2 // 7
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73 // 8
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb // 9
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79 // a
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08 // b
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a // c
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e // d
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf // e
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 // f


*/

/*	Inverse S-BOX
   	// 0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, // 0
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, // 1
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, // 2
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, // 3
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, // 4
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, // 5
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, // 6
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, // 7
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, // 8
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, // 9
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, // a
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, // b
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, // c
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, // d
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, // e
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};// f
*/



static uint8_t sBOX[16][16] = 
{
	{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76},
	{0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0},
	{0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15},
	{0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75},
	{0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84},
	{0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf},
	{0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8},
	{0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2},
	{0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73},
	{0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb},
	{0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79},
	{0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08},
	{0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a},
	{0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e},
	{0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf},
	{0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16}
}; // end of S-BOX



static uint8_t inv_sBOX[16][16] = 
{
	{0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb},
	{0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb}, 
	{0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e}, 
	{0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25}, 
	{0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92}, 
	{0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84}, 
	{0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06}, 
	{0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b}, 
	{0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73}, 
	{0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e}, 
	{0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b}, 
	{0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4}, 
	{0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f}, 
	{0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef}, 
	{0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61}, 
	{0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d}
}; // end of inverse S-BOX

// Set values
int Nk, Nr, key_size = 0;
int Nb = 4;

// Round Constant
uint8_t R[] = {0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36};


// Display Array
void display_matrix(uint8_t *a, int columns_size, int size){

    int index = 0;

    printf("   ");
    for(int i=0; i<columns_size; i++){
        printf("%2d ", i);
    }

    printf("\n%2d ", index++);
    for(int i=0; i<size; i++){
        if(i%columns_size == 0 && i != 0){
            printf("\n%2d ", index++);
        }
        printf("%02x ", a[i]);

    }
    printf("\n ------------------end\n\n");
} // ENd of display_Matrix

void display_2(uint8_t (*a)[4]){
	for(int i=0; i<4; i++){
		for(int j=0; j<4; j++){
			printf("%02x ", a[i][j]);
		}
		printf("\n");
	}
}


// Bits shift and deal with Carry
uint8_t xtime(uint8_t a){
	uint8_t hex = a;
	uint8_t carry = 0x01b;
	hex <<= 1;

	if(hex > 0xff){
		hex -= 0x100;
		hex ^= carry;
	}

	return hex;
}

//  Add Round Key function State(=text) XOR Round key
void add_round_key(uint8_t (*state)[4], uint8_t *key, int r){

	for(int i=0; i<4; i++){
		// State XOR Key
		state[i][0] = state[i][0]^key[16*r + 4*i+0];
		state[i][1] = state[i][1]^key[16*r + 4*i+1];
		state[i][2] = state[i][2]^key[16*r + 4*i+2];
		state[i][3] = state[i][3]^key[16*r + 4*i+3];
	}

} // end of add_round_key

// Sub byte function that conduct substitute using S-BOX 
void sub_byte(uint8_t (*state)[4]){
	int i, j = 0;
	uint8_t hex = 0;
	
	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			hex = state[i][j];
			state[i][j] = sBOX[hex/16][hex%16];
		}
	}
	
} // end of sub_byte


// Inverse Sub Byte function that conduct inverse substitute using inversed S-BOX
void inv_sub_byte(uint8_t (*state)[4]){
	int i, j = 0;
	uint8_t hex = 0;

	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			hex = state[i][j];
			state[i][j] = inv_sBOX[hex/16][hex%16];
		}
	}	

} // end of inv_sub_byte

// Shift Row function 
// Shift row by 0, 1, 2, 3 toward left
void shift_row(uint8_t (*state)[4]){
	int i, j = 0;
	uint8_t temp[4][4];

	// Shift row to the left and input into Temp matrix
	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			temp[i][j] = state[i][(4+i+j)%4];
		}
	}
	
	// State matrix is copied by Temp matrix
	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			state[i][j] = temp[i][j];
		}
	}
} // end of shift_row

// Inverse Shift Row function
// Shift row by 0, 1, 2, 3 toward right
void inv_shift_row(uint8_t (*state)[4]){
	int i, j = 0;
	uint8_t temp[4][4];
	
	// Shift row to the right and input into Temp matrix
	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			temp[i][j] = state[i][(4-i+j)%4];
		}
	}
	
	// State matrix is copied by Temp matrix
	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			state[i][j] = temp[i][j];
		}
	}

} // end of inv_shift_row

// Multiply Matrix function for mix columns
uint8_t multi_matrix(uint8_t *a, uint8_t *b){

	uint8_t temp[4], b_temp[4] = {0};
    int res, tmp;

	for(int i =0; i<4; i++){
		b_temp[i] = b[i];
	}

    // Binary Multiply by 0x01, 0x02, 0x03
    for(int i=0; i<4; i++){
        switch (a[i]){
            case 0x01:
                temp[i] = b_temp[i];
                break;
            case 0x02:
                temp[i] = xtime(b_temp[i]);
                break;
            case 0x03:
               	tmp = b_temp[i];
                b_temp[i] = xtime(b_temp[i]);
                temp[i] = b_temp[i] ^ tmp;
                break;
            case 0x09:
                tmp = b_temp[i];
                b_temp[i] = xtime(b_temp[i]);
                b_temp[i] = xtime(b_temp[i]);
                b_temp[i] = xtime(b_temp[i]);
                temp[i] = b_temp[i] ^ tmp;
                break;
            case 0x0b:
                tmp = b_temp[i];
                b_temp[i] = xtime(b_temp[i]);
                b_temp[i] = xtime(b_temp[i]);
                b_temp[i] ^= tmp;
                b_temp[i] = xtime(b_temp[i]);
                temp[i] = b_temp[i] ^ tmp;
                break;
            case 0x0d:
                tmp = b_temp[i];
                b_temp[i] = xtime(b_temp[i]);
				b_temp[i] ^= tmp;
                b_temp[i] = xtime(b_temp[i]);
                b_temp[i] = xtime(b_temp[i]);
                temp[i] = b_temp[i] ^ tmp;
                break;
            case 0x0e:
                tmp = b_temp[i];
                b_temp[i] = xtime(b_temp[i]);
                b_temp[i] ^= tmp;
                b_temp[i] = xtime(b_temp[i]);
                b_temp[i] ^= tmp;
                temp[i] = xtime(b_temp[i]);
                break;
        }
    }

    res = temp[0]^temp[1]^temp[2]^temp[3];
    return res;

} // end of multi_matrix

void mix_columns(uint8_t (*state)[4]){
	uint8_t threadhold[4][4] = {
	{0x02, 0x03, 0x01, 0x01},
	{0x01, 0x02, 0x03, 0x01},
	{0x01, 0x01, 0x02, 0x03},
	{0x03, 0x01, 0x01, 0x02}
	}; 
	uint8_t temp[4], res[4];	
	int i, j = 0;

	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			temp[j] = state[j][i];
		}
		for(j=0; j<4; j++){	
			state[j][i] = multi_matrix(threadhold[j], temp);
		}
	}
} // end of mix_columns

void inv_mix_columns(uint8_t (*state)[4]){
	uint8_t threadhold[4][4] = {
	{0x0e, 0x0b, 0x0d, 0x09},
	{0x09, 0x0e, 0x0b, 0x0d},
	{0x0d, 0x09, 0x0e, 0x0b},
	{0x0b, 0x0d, 0x09, 0x0e}
	};
	uint8_t temp[4], res[4];
	int i, j = 0;

	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			temp[j] = state[j][i];
		}

		for(j=0; j<4; j++){
			state[j][i] = multi_matrix(threadhold[j], temp);
		}
	}
} // end of inv_mix_columns


/* Key Scheduler Functions */
void rot_word(uint8_t *w){
    uint8_t tmp, i;

    tmp = w[0];

    for(i=0; i<3; i++){
        w[i] = w[i+1];
    }

    w[3] = tmp;
}

void sub_word(uint8_t *w){
    int i;
    for(i=0; i<4; i++){
        w[i] = sBOX[w[i]/16][w[i]%16];
    }
}

void key_init(int keysize){
    key_size = keysize;

    switch(key_size){
        case 16:
            Nk = 4; Nr = 10;
            break;
        case 24:
            Nk = 6; Nr = 12;
            break;
        case 32:
            Nk = 8; Nr = 14;
            break;
        default:
            Nk = 4; Nr = 10;
            break;
    }


}

// Key Expansion
void key_expansion(uint8_t *key, uint8_t *Round_key){
    int i, j, count = 0;
    uint8_t temp[4], k;
	
	display_matrix(Round_key, 16, Nb*(Nr+1)*4);
	printf("### Start Key Expansion function\n");
	printf("Values INFO\n");
	printf("Nr = %d, Nb = %d, Nk = %d\n",Nr, Nb, Nk);
	// Initialize: Round_key[0]
    for(i=0; i<4; i++){
        Round_key[i * 4] = key[i * 4];
        Round_key[i * 4 + 1] = key[i * 4 + 1];
        Round_key[i * 4 + 2] = key[i * 4 + 2];
        Round_key[i * 4 + 3] = key[i * 4 + 3];
    }
	
	// Expand key by used before key.
    while (i < (Nb * (Nr + 1))){
        for(j=0; j<4; j++){
            temp[j] = Round_key[(i-1) * 4 + j];
		}
        if(i%Nk == 0){
            rot_word(temp);
            sub_word(temp);
            temp[0] ^= R[count++];
        }
        else if(Nk > 6 && i%Nk == 4){
            sub_word(temp);
        }

        for(j=0; j<4; j++){
            Round_key[i*4 + j] = Round_key[(i-Nk) * 4 + j] ^ temp[j];
        }
        i++;
    }
	
    printf("Success Key Expansion...\n");
	display_matrix(Round_key, 16, Nb*(Nr+1)*4);
} // END of Key_expansion

/*
	AES functions
	void add_round_key(uint8_t (*state)[4], uint8_t (*key)[4])
	void sub_byte(uint8_t (*state)[4])
	void shift_row(uint8_t (*state)[4])
	void mix_columns(uint8_t (*state)[4])
*/
void aes_enc(uint8_t (*plain)[4], uint8_t (*cipher)[4], uint8_t *key){
	uint8_t state[4][4];
	uint8_t r, i, j;

	// Cppy plain text into state array
	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			state[i][j] = plain[i][j];
		}
	}

	// Operate AES Encrypt
	add_round_key(state, key, 0);
	
	// printf("Compute Encrypt...\n");
	for(r=1; r<10; r++){
		sub_byte(state);
		shift_row(state);
		mix_columns(state);
		add_round_key(state, key, r);
	}

	sub_byte(state);
	shift_row(state);
	add_round_key(state, key, 10);
	
	// set Cipher text
	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			cipher[i][j] = state[i][j];
		}
	}

	printf("Success AES Encrypt!\n");

} // End of aes_encrypt
	
void aes_dec(uint8_t (*cipher)[4], uint8_t (*plain)[4], uint8_t *key){
	uint8_t state[4][4];
	uint8_t r, i, j;
	
	// Copy cipher text into state array
	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			state[i][j] = cipher[i][j];
		}
	}
	
	// Operate AES Decrypt
	add_round_key(state, key, 10);

	// printf("Compute Decrypt...\n");
	for(r=9; r>=1; r--){
		inv_shift_row(state);
		inv_sub_byte(state);
		add_round_key(state, key, r);
		inv_mix_columns(state);
	}
	
	inv_shift_row(state);
	inv_sub_byte(state);
	add_round_key(state, key, 0);

	// set Plain text
	for(i=0; i<4; i++){
		for(j=0; j<4; j++){
			plain[i][j] = state[i][j];
		}
	}
	
	printf("Success AES Decrypt!\n");
	
	
} // End of aes_decrypt

void big_convert(char *string, uint8_t *out){
	int len = strlen(string);

	for(int i=0; i<len; i++){
		out[i] = string[i];
	}
}

void big_inv_convert(uint8_t *in, char *string){
	int len = strlen(string);

	for(int i=0; i<len; i++){
		string[i] = in[i];
	}

	string[len] = '\0';
}


// Encrypt CTR mod
uint8_t *enc_ctr(uint8_t (*iv)[4], char *msg, uint8_t *key){
	char *pad_res;
	uint8_t *ctr_res, *temp_uint8;
	uint8_t cipher[4][4], temp[16] = { 0,};
	int count_mod, s_len;

	s_len = strlen(msg);
	count_mod = s_len / 16;
	
	// If msg byte is not divisiable 16
	if(s_len % 16 != 0){
		count_mod  += 1;
	}
	printf("%d: %s\n",s_len, msg);
	

	// Initialize Memory locale
	ctr_res = (uint8_t *)malloc(sizeof(uint8_t) * 16 * (count_mod));
	temp_uint8 = (uint8_t *)malloc(sizeof(uint8_t) * 16 * (count_mod));
	pad_res = (char *)malloc(sizeof(char) * 16 * (count_mod));
	memset(pad_res, 0, sizeof(pad_res));
	
	printf("Init Matrix in enc_ctr\n");
	strncpy(pad_res, msg, s_len);
 	big_convert(pad_res, temp_uint8);
	
	// display Matrix
	for(int i=0; i<count_mod; i++){
		for(int j=0; j<16; j++){
			printf("%02x " ,temp_uint8[i*16+j]);
		}
		printf("\n");
	}


	// Compute Encrypt 
	for(int i=0; i<count_mod; i++){
		aes_enc(iv, cipher, key);

		// XOR Plain text(after Padding) and Encrypted IV
		for(int j=0; j<16; j++){
			ctr_res[16*i+j] = temp_uint8[16*i+j] ^ cipher[j/4][j%4];
		}

		// Increase Initial Value
		iv += 1;
	}
	
	return ctr_res;
}
 
// Dencrypt CTR mod
char *dec_ctr(uint8_t (*iv)[4], uint8_t *cipher, uint8_t *key){
	char *dec_res;
	uint8_t *temp_uint8;
	uint8_t temp_cipher[4][4];
	int count_mod, s_len;

	s_len = strlen(cipher);
	count_mod = s_len / 16;

	printf("Init Matrix in dec_ctr\n");
	dec_res = (char *)malloc(sizeof(char) * 16 * count_mod);
	temp_uint8 = (uint8_t *)malloc(sizeof(uint8_t) * 16 * count_mod);

	// display Matrix
	for(int i=0; i<count_mod; i++){
		for(int j=0; j<16; j++){
			printf("%02x ", cipher[i*16 + j]);
		}

		printf("\n");
	}
	printf("\n");


	// Compute Decrypt
	for(int i=0; i<count_mod; i++){
		aes_enc(iv, temp_cipher, key);

		// XOR Cipher Text and Encrypt IV
		for(int j=0; j<16; j++){
			temp_uint8[16*i+j] = cipher[16*i+j] ^ temp_cipher[j/4][j%4]; 
		}
		
		// Increase Initial Value
		iv += 1;
	}

	big_inv_convert(temp_uint8, dec_res);
	
	return dec_res;
}
